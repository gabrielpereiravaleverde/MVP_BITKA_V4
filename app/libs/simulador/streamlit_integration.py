from typing import Dict, List, Any, Tuple
import plotly.graph_objs as go
from interpret.glassbox import ExplainableBoostingRegressor
import pandas as pd
import streamlit as st
from libs.simulador.business_logic import *

def update_chart_layout(fig: go.Figure, y_values: List[float]) -> None:
    """
    Update the layout of a waterfall chart.

    Args:
        fig (go.Figure): Plotly figure object.
        y_values (List[float]): y values for the chart to determine axis range.
    """
    
    # Calculate the cumulative sum and store the intermediate sums
    cumulative_values = []
    cumulative_sum = y_values[0]  # Assume the first value is the starting value
    for y in y_values[1:-1]:  # Excluding the last value (predicted value)
        cumulative_sum += y
        cumulative_values.append(cumulative_sum)

    # Determine the y-axis range based on the cumulative values
    min_y = min(cumulative_values)
    max_y = max(cumulative_values)

    fig.update_layout(
        title="", ## EDITAR TITULO ANTES DA BOOBLE BOX
        showlegend=True
    )
    fig.update_yaxes(range=[min_y -1, max_y + 1])

def generate_waterfall_chart(
    base_prediction: float, 
    selected_impacts: Dict[str, float], 
    other_impacts_sum: float,
    final_prediction: float
) -> go.Figure:
    x_labels, y_values = prepare_data_for_chart(base_prediction, selected_impacts, other_impacts_sum, final_prediction)
    fig = create_waterfall_chart(x_labels, y_values, final_prediction)
    update_chart_layout(fig, y_values)
    return fig


def get_selected_variables(selected_stage: str, etapas: Dict[str, List[Tuple[str, str]]]) -> List[str]:
    """
    Get the selected variables based on the chosen stage.

    Args:
        selected_stage (str): The stage selected for analysis.
        etapas (dict): Dictionary containing etapas and their variables with units.

    Returns:
        list: List of selected variable names.
    """
    if selected_stage == "Todas":
        return [variable for stage_key in etapas for variable_type, variable_tuples in etapas[stage_key].items() for variable, _ in variable_tuples]
    return [variable for variable_type, variable_tuples in etapas[selected_stage].items() for variable, _ in variable_tuples]

def update_visualization(selected_stage: str, input_df: pd.DataFrame, model: ExplainableBoostingRegressor, y: pd.Series, etapas: Dict[str, Any]):
    """
    Update and generate a visualization based on the selected stage, input data, model, and target series.

    This function calculates the individual impacts of selected variables on a model's prediction, 
    visualizes these impacts using a waterfall chart, and computes the combined impact of all other 
    non-selected variables.

    Args:
        selected_stage (str): The stage selected by the user, used to determine which variables to include.
        input_df (pd.DataFrame): The input data DataFrame for which the impacts are to be calculated.
        model (ExplainableBoostingRegressor): The model used to compute the predictions and impacts.
        y (pd.Series): The target series against which the model's predictions are compared.
        etapas (Dict[str, Any]): A dictionary defining the stages and their associated variables.

    Returns:
        A waterfall chart generated by the `generate_waterfall_chart` function, showing the impacts of 
        the selected variables, the combined impact of other variables, and the final prediction.

    The function first retrieves the variables relevant to the selected stage, calculates the base prediction 
    and the impacts of each variable on the model's prediction. It then extracts and sums the impacts of 
    the selected variables, and calculates the collective impact of the remaining variables. This data is 
    then used to generate a waterfall chart that visually represents these impacts and the final prediction.
    """
    selected_variables = get_selected_variables(selected_stage, etapas)

    base_prediction, impacts_dict = calculate_impacts(input_df, model, y)

    # Impacts das variáveis selecionadas
    selected_impacts = {k: v for k, v in impacts_dict.items() if k in selected_variables}
    
    # A previsão final usando o modelo
    final_prediction = base_prediction + sum(impacts_dict.values())
    # A soma dos impactos das variáveis selecionadas
    sum_selected_impacts = sum(selected_impacts.values())

    # O impacto conjunto das variáveis não selecionadas é a diferença necessária
    # para que a soma dos impactos selecionados mais a base_prediction seja igual à final_prediction
    other_impacts_sum = final_prediction - (base_prediction + sum_selected_impacts)

    # Adicionar o impacto conjunto ao dicionário de impactos selecionados para visualização
    selected_impacts["Impacto Conjunto das Outras Variáveis"] = other_impacts_sum

    # Chama a função generate_waterfall_chart com todos os quatro argumentos necessários
    return generate_waterfall_chart(base_prediction, selected_impacts, other_impacts_sum, final_prediction)

def simulate(
    input_values_simulator: Dict[str, float], 
    selected_stage: str, 
    model: ExplainableBoostingRegressor, 
    y: pd.Series, 
    etapas: Dict[str, Any],
    session_state: st.session_state
) -> None:
    """
    Perform simulation based on user inputs and update the visualization.

    Args:
        input_values_simulator (Dict[str, float]): The input values collected from the user interface.
        selected_stage (str): The current stage selected by the user.
        model (ExplainableBoostingRegressor): The machine learning model used for prediction.
        y (pd.Series): The target variable used by the model.
        etapas (Dict[str, Any]): Dictionary containing configuration or information about the stages.
        session_state (st.session_state): Streamlit's session state object for storing session-specific variables.

    This function updates the Streamlit session state with the results of the simulation.
    """
    session_state.simulated = True
    input_df = pd.DataFrame([input_values_simulator])
    session_state.current_values = input_df
    predicted_value = model.predict(input_df)[0]
    session_state.predicted_value = predicted_value.round(2)
    session_state.last_fig = update_visualization(
        selected_stage, 
        input_df, 
        model, 
        y, 
        etapas
    )

def update_plot_based_on_stage(selected_stage: str, input_df: pd.DataFrame, model: ExplainableBoostingRegressor, y: pd.Series, etapas: Dict[str, Any]) -> go.Figure:
    """
    Update the visualization plot based on the selected stage.

    Args:
        selected_stage (str): The stage selected for visualization.
        input_df (pd.DataFrame): DataFrame containing input data used for the simulation.
        model (ExplainableBoostingRegressor): The machine learning model used for prediction.
        y (pd.Series): The target variable used by the model.
        etapas (Dict[str, Any]): Dictionary containing etapas and their variables with units.

    Returns:
        go.Figure: The updated Plotly figure object reflecting the selected stage.
    """
    input_df = pd.DataFrame([input_df])

    # Get the selected variables for the chosen stage
    selected_variables = get_selected_variables(selected_stage, etapas)

    # Ensure the target variable is not included in the selected variables for plotting
    selected_variables_for_plot = [var for var in selected_variables if var != 'CONC_ROUG_FC01_CUT']

    # Filter the input dataframe based on the selected variables
    filtered_df = input_df[selected_variables_for_plot]

    # Recalculate impacts if necessary
    base_prediction, impacts_dict = calculate_impacts(filtered_df, model, y)
    selected_impacts = {k: v for k, v in impacts_dict.items() if k in selected_variables_for_plot}
    # Generate the waterfall chart with the selected impacts
    return generate_waterfall_chart(base_prediction, selected_impacts, base_prediction + sum(impacts_dict.values()))
